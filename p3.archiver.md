# Archiver

####

Software Heritage manipule de grandes quantités de données qui doivent
être répliquées sur plusieurs serveurs. Le but de l'archiver est de
gérer la synchronisation des noeuds de stockage, afin que l'ensemble
du réseau contienne toujours au moins $N$ copies de chaque fichier
source.

## Motivations

####

Se référer aux annexes \ref{software-heritage-archiver-version-1}
p.\pageref{software-heritage-archiver-version-1} pour les
spécifications de la première version et
\ref{software-heritage-archiver-version-2}
p.\pageref{software-heritage-archiver-version-2} pour celles de la
seconde.

####

Bien que les deux aient été développées entièrement, cette section ne
décrit que la seconde car leur fonctionnement est très similaire.

## Fonctionnement

####

L'archiver est constitué de trois classe qui orchestrent la copie des
fichiers à partir des informations de copie de la base de donnée

### Base de données

####

Dans la base de donnée de l'archiver de Software Heritage (Voir
\ref{db-archiver} p.\pageref{db-archiver}), la table `content_archive`
contient pour chaque objet référencé un objet json de la forme
suivante :

```json
	{
		"node name": {
			"status": "<status>",
			"mtime": "<last update time>"
		}
	}
```

####

Il s'agit d'une dénormalisation de la table représentée par
`content_status` sur le schéma \ref{db-archiver}
p.\pageref{db-archiver}.

####

![Schéma de la base de donnée de l'archiver \label{db-archiver}](db_archiver.pdf)

####

Si un noeud est connu de l'archiver (contenu dans sa base de donnée)
mais n'est pas renseigné pour un contenu, le contenu est considéré
absent sur ce noeud.

### ArchiverDirector

####

Le directeur (`ArchiverDirector`) a pour rôle d'itérer sur les objets
référencés par la base de donnée et de créer des paquets avec ceux qui
sont susceptibles de nécessiter une copie supplémentaire.

####

Sont *susceptibles* de nécessiter une copie supplémentaire les objets
qui ont moins de noeuds sur lequel ils sont présent (au sens strict,
uniquement ceux pour qui le champ `archive_status` est `'present'`) que
requis par la configuration de l'archiver.

####

Ces contenus nécessitant d'être archivés sont assemblés par lot et ces
lots mis dans une file d'attente où ils seront consommés par des
workers.

### ArchiverWorker

####

Lorsqu'un worker[^worker-archiver] consomme un des lots mis dans la
file par le director, il instancie un `ArchiverWorker` dont le rôle
est de parcourir le lot pour préparer la copie.

[^worker-archive]: Dans le sens d'une des machines virtuelles citées dans \ref{workers} p.\pageref{workers}.

####

Pour chaque objet que le director a sélectionné précédemment, le worker
vérifie qu'il est toujours nécessaire de le copier. Le worker s'assure
donc que l'object n'a toujours pas le nombre requis de copies, en
prenant en compte plus finement le statut `'ongoing'`

####

Si un objet est `'ongoing'` mais que le délai depuis la dernière mise
à jour du status (calculé avec le champ `'mtime'`) est inférieur au
délai maximum autorisé par le worker, une copie est déjà en cours ; on
considère qu'elle va réussir et que le contenu sera présent sur le
noeud, il est donc considéré comme tel lorsque le worker compte le
nombre de copies existantes pour savoir s'il conserve cet objet.

####

A l'inverse, si le délai est écoulé, la copie est considérée comme un
échec et le noeud n'est pas considéré comme contenant l'objet.

####

Pour chaque contenu qui est toujours candidat à être copié, le worker
choisit au hasard un noeud source parmi ceux qui contiennent déjà
l'objet, et un noeud destination parmi ceux sur lequel il est
absent. Si plus d'une copie est requise, le worker choisit autant de
couples (source, destination) que nécessaire.

####

Pour chaque couple (source, destination), le worker regroupe les
objets qui sont associé au couple. Il effectue alors pour chaque
contenu un contrôle d'intégrité de l'objet sur son noeud source. Si
une erreur est détectée (objet absent ou contenu corrompu), il met à
jour la base de donnée avec le nouveau status (`'missing'` ou
`'corrupted'`), logue l'erreur, et retire l'objet de sa liste.

####

Pour les objets restants, le worker met à jour leur entrée dans la
base de donnée pour indiquer que leur copie est en cours avec le
status `'ongoing'`, puis il instancie localement un `ArchiverCopier`
et le fait effectuer la copie avant de passer au couple de noeuds
suivant.

### ArchiverCopier

####

L'`ArchiverCopier` est initialisé avec une source, une destination, et
une liste d'objets qui ont été sélectionnés par le worker pour être
copiés de l'un à l'autre.

####

Le copier ouvre la connexion avec les noeuds, et pour chaque objet,
fait une requête pour le récupérer depuis la source, puis l'ajoute à
la destination.

####

A l'issue de la copie, si tout s'est bien passé, la base de donnée est
mise à jour pour refléter la présence des objets nouvellement
copiés. Si une erreur s'est produite en revanche, tout le lot du
copier est annulé. Leur statut `'ongoing'` expirera et ils seront de
nouveau planifiés pour une copie.
