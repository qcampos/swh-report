# Object Storage

####

Lorsque les fichiers source sont capturés par un loader (voir
\ref{loaders} p.\pageref{loaders}), ils sont enregistrés dans
l'**object storage** dont le but est de conserver les fichiers et d'en
restituer leur contenu à la demande.


## Fonctionnement (k-v, hash, api)

####

Un fichier source enregistré dans l'object storage est adressable par
contenu, c'est à dire qu'on peut retrouver son identifiant (son
adresse) à partir de son contenu. Dans le cas de Software Heritage,
nos objets sont identifiés par leur sha1.

####

Initialement, l'object storage était une classe entièrement dépendante
du storage, et n'existait pas sans elle (voir figure
\ref{storage-initial} p.\pageref{storage-initial}). Au cours du
développement, l'object storage a pris de plus en plus d'importance et
d'indépendance jusqu'à être déplacé dans son propre package python
(depuis `swh.storage.objstorage` vers `swh.objstorage`.

![Architecture initiale du Storage \label{storage-initial}](images/storage_initial.pdf)



## Les modifications

- RemoteObjStorage API
- Introduction de la classe abstraite `ObjStorage`
- La découpe des path dans `PathSlicingObjStorage` est désormais un
  paramètre de la config
- ObjStorage multiplexer + filtres
- Extraction depuis the `swh.storage.objstorage` vers `swh.objstorage`
  avec commits
- Initialisation facile des ObjStorages depuis `get_objstorage(class,
  **storage_args)`
- Modification de l'API afin d'ajouter `get_batch` (avec une
  implémentation par défaut)
- (Wip) Implémentation du CloudObjStorage avec Libcloud

## Content integrity checker

- Implémentation de base
- Modification suite à l'ajout du statut corrupted + Refactor pour
  extension facile
