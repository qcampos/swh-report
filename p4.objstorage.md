# Object Storage

####

Lorsque les fichiers source sont capturés par un loader (voir
\ref{loaders} p.\pageref{loaders}), ils sont enregistrés dans
l'**object storage** dont le but est de conserver les fichiers et d'en
restituer leur contenu à la demande.

## Principe et fonctionnement

####

L'object storage de Software Heritage est un *blob-storage*
clef-valeur dans lequel chaque *blob* est référencé par son sha1 (voir
\ref{data-model} p.\pageref{data-model}).

####

Initialement, l'object storage était une classe entièrement dépendante
du storage, et n'existait pas sans elle (voir figure
\ref{storage-initial} p.\pageref{storage-initial}). Au cours du
développement, l'object storage a pris de plus en plus d'importance et
d'indépendance jusqu'à être déplacé dans son propre package python
(depuis `swh.storage.objstorage` vers `swh.objstorage`.

![Architecture initiale du Storage \label{storage-initial}](storage_initial.pdf)



## Les modifications

####

Cette section détaille les évolutions de l'object storage.

### RemoteObjStorage API

####

Créer l'archiver (voir \ref{archiver} p.\pageref{archiver}) nécessite
d'avoir sur la machine de sauvegarde un moyen de recevoir les objets
copiés et de les stocker de la même manière que sur la machine
source : un serveur http qui puisse recevoir les requêtes nécessaires
et les déléguer à un *blob-storage*.

####

Comme les données sauvegardées n'ont pas besoin d'être manipulées mais
uniquement présentes, déployer un serveur `Storage` (qui possède déjà
une version remote http) implique une surcouche contingente.

####

Afin de remplir les objectifs de l'archiver tout en étant efficace, il
a fallu ajouter un serveur http pour l'object storage. Le schéma
\ref{objstorage-api} p.\pageref{objstorage-api} montre le
fonctionnement de cette nouvelle API.

![API http pour ObjStorage \label{objstorage-api}](objstorage_api.pdf)


### Interface ObjStorage

####

L'introduction de ce `RemoteObjStorage` (voir section précédente
\ref{remoteobjstorage-api} p.\pageref{remoteobjstorage-api}) qui
possède les mêmes fonctionnalités et une API similaire à
l'`ObjStorage`, induit la nécéssité d'une interface commune afin que
les modifications d'API n'empêchent pas le duck typing de fonctionner
correctement et les deux types d'object storage d'être interchangés de
manière invisible.

####

- Introduction de la classe abstraite `ObjStorage`
- La découpe des path dans `PathSlicingObjStorage` est désormais un
  paramètre de la config
- ObjStorage multiplexer + filtres
- Extraction depuis the `swh.storage.objstorage` vers `swh.objstorage`
  avec commits
- Initialisation facile des ObjStorages depuis `get_objstorage(class,
  **storage_args)`
- Modification de l'API afin d'ajouter `get_batch` (avec une
  implémentation par défaut)
- (Wip) Implémentation du CloudObjStorage avec Libcloud

## Content integrity checker

- Implémentation de base
- Modification suite à l'ajout du statut corrupted + Refactor pour
  extension facile
